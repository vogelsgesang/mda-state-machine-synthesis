modeltype IOAutomatonModel uses "urn:io-automaton/1.0";
modeltype CommonConcepts uses "urn:commonconcepts/1.0";

transformation mergeIoAutomaton(in automatons:IOAutomatonModel, out diagram:IOAutomatonModel);

main() {
	automatons.rootObjects()[AutomatonCollection]->map merge();
}

mapping IOAutomatonModel::AutomatonCollection::merge() : IOAutomatonModel::Automaton {
	init {
		log("Start merge()");
	}
	
	var mainActorNames := self.automatons.mainActor.name->asSet();
	var automatonsResult := object AutomatonCollection{};
	mainActorNames->forEach(mainActorName | true) {
		var automatonsForActor := self.automatons->select(automaton | automaton.mainActor.name = mainActorName);
		var mergedAutomaton := automatonsForActor.mergeStatesAndTransitions();
		var mainActor := object SystemActor{};
		mainActor.name := mainActorName;
		mergedAutomaton.mainActor := mainActor;
		automatonsResult.automatons += mergedAutomaton;
	}
	
	end {
		log("Finished automatons merge()");		
	}
}

mapping IOAutomatonModel::AutomatonCollection::getStates() : Set(IOAutomatonModel::State) {
	init {
		result := Set{};	
		self.automatons->forEach(automaton | true) {
			result += automaton.states.deepclone().oclAsType(IOAutomatonModel::State);
		}
	}	
}

mapping IOAutomatonModel::AutomatonCollection::getTransitions() : Set(IOAutomatonModel::Transition) {
	init {
		result := Set{};
		self.automatons->forEach(automaton | true) {
			result += automaton.transitions.deepclone().oclAsType(IOAutomatonModel::Transition);
		}
	}	
}

helper Set(Automaton)::mergeStatesAndTransitions() : Automaton {
	var uniqueStates : Set(State) := Set{};
	self->forEach(automaton | true) {
		automaton.states->forEach(state | not uniqueStates.isStateContained(state)) {
			uniqueStates += state.deepclone().oclAsType(State);
		};
	};
	
	var uniqueTransitions : Set(Transition) := Set{};
	self->forEach(automaton | true) {
		automaton.transitions->forEach(transition | not uniqueTransitions.isTransitionContained(transition)) {
			uniqueTransitions += transition.deepclone().oclAsType(Transition);
		};
	};
	
	
	var automaton := object Automaton{};
	automaton.states := uniqueStates;
	automaton.transitions := uniqueTransitions;
	automaton.startState := self->first().oclAsType(Automaton).startState;
	return automaton;
}

query Set(State)::isStateContained(state : State) : Boolean {
	var stateName = state.name;
	return self->forAll(setState | setState.name = stateName);
}

query Set(Transition)::isTransitionContained(transition : Transition) : Boolean {
	var outMessages := transition.outMessages;
	self->forEach(setTransition 
					| setTransition.operation.name = transition.operation.name
					and setTransition.preState.name = transition.preState.name
					and setTransition.postState.name = transition.postState.name) {
		// operation, pre and post equal
		// now check the outMessages
		var outProduct := outMessages->product(setTransition.outMessages);
		var equalCount := 0;
		outProduct->forEach(outProdTuple | true) {
			var first := outProdTuple.first;
			var second := outProdTuple.second;
			if (first.operation.name = second.operation.name
					and first.receiver.name = second.receiver.name
					and first.returnValue.value = second.returnValue.value) {
				equalCount := equalCount + 1;
			}
		};
		if(equalCount = outMessages->size()) {
			return true;
		}
	};
	return false;
}
