modeltype BehaviourModel uses "urn:behaviour/1.0";
modeltype IOAutomatonModel uses "urn:io-automaton/1.0";
modeltype CommonConcepts uses "urn:commonconcepts/1.0";

transformation behaviourToAutomaton(in table:BehaviourModel, out diagram:IOAutomatonModel);

property ioStates : Set(IOAutomatonModel::State);

main() {
	table.objectsOfType(BehaviourCollection)->map toAutomatonCollection();
}

mapping BehaviourModel::BehaviourCollection::toAutomatonCollection() : IOAutomatonModel::AutomatonCollection {
	result.automatons := self.behaviours->map toAutomaton();
}

mapping BehaviourModel::Behaviour::toAutomaton() : IOAutomatonModel::Automaton {
	
	init {
		log("Start mapping toAutomaton()");
	}
	
	result.transitions := self.blocks->map toTransition();
	result.mainActor := self.mainActor.deepclone().oclAsType(CommonConcepts::SystemActor);
	result.states := ioStates;
	
	//TODO: startState
	
	end {
		log("Finished mapping toAutomaton()");		
	}
}


mapping BehaviourModel::Block::toTransition() : IOAutomatonModel::Transition {
	
	init {
		log("Start mapping toStatesAndTransition()");
	}
	
	result.preState := self.preState.transformState();
	result.postState := self.postState.transformState();

	result.operation := self.inMessage.operation.deepclone().oclAsType(CommonConcepts::Operation);
	result.returnValue := self.activation.returnValue.deepclone().oclAsType(CommonConcepts::Return);
	result.outMessages := self.activation.outMessages->map transformOutMessage();
		
	end {
		log("Finished mapping toStatesAndTransition()");		
	}
}


mapping BehaviourModel::OutMessage::transformOutMessage() : IOAutomatonModel::OutMessage {
	operation := self.operation.deepclone().oclAsType(CommonConcepts::Operation);
	receiver := self.receiver.deepclone().oclAsType(CommonConcepts::Actor);
	returnValue := self.returnValue.deepclone().oclAsType(CommonConcepts::Return);
}

//transforms a State from the Behaviour model to an IOAutomaton-State
//if the State has already been transformed before, ie. exists in the set of ioStates, use the existing one
//else create new IOAutomaton-State
helper CommonConcepts::State::transformState() : IOAutomatonModel::State {
	if(ioStates.name->includes(self.name)) {
		return self.resolveone(s : IOAutomatonModel::State | s.name = self.name);
	}
	else {
		var state : IOAutomatonModel::State := object IOAutomatonModel::State {};
		state.name := self.name;
		ioStates += state;
		return state;
	};
}



