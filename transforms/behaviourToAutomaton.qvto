modeltype BehaviourModel uses "urn:behaviour/1.0";
modeltype IOAutomatonModel uses "urn:io-automaton/1.0";
modeltype CommonConcepts uses "urn:commonconcepts/1.0";

transformation behaviourToAutomaton(in table:BehaviourModel, out diagram:IOAutomatonModel);


main() {
	table.objectsOfType(BehaviourCollection)->map toAutomatonCollection();
}

mapping BehaviourModel::BehaviourCollection::toAutomatonCollection() : IOAutomatonModel::AutomatonCollection {
	result.automatons := self.behaviours->map toAutomaton();
}

mapping BehaviourModel::Behaviour::toAutomaton() : IOAutomatonModel::Automaton {
	
	init {
		log("Start mapping toAutomaton()");
	}
	
	result.transitions := self.blocks->map toTransition(result);
	result.mainActor := self.mainActor.deepclone().oclAsType(CommonConcepts::SystemActor);
	
	//TODO: startState
	
	end {
		log("Finished mapping toAutomaton()");		
	}
}


mapping BehaviourModel::Block::toTransition(inout automaton : IOAutomatonModel::Automaton) : IOAutomatonModel::Transition {
	
	init {
		log("Start mapping toTransition()");
	}
	
	result.preState := self.preState.transformState(automaton);
	result.postState := self.postState.transformState(automaton);

	result.operation := self.inMessage.operation.deepclone().oclAsType(CommonConcepts::Operation);
	result.returnValue := self.activation.returnValue.deepclone().oclAsType(CommonConcepts::Return);
	result.outMessages := self.activation.outMessages->map transformOutMessage();
		
	end {
		log("Finished mapping toTransition()");		
	}
}


mapping BehaviourModel::OutMessage::transformOutMessage() : IOAutomatonModel::OutMessage {
	operation := self.operation.deepclone().oclAsType(CommonConcepts::Operation);
	receiver := self.receiver.deepclone().oclAsType(CommonConcepts::Actor);
	returnValue := self.returnValue.deepclone().oclAsType(CommonConcepts::Return);
}

//transforms a State from the Behaviour model to an IOAutomaton-State
//if the State has already been transformed before, ie. exists in the automaton's set of already mapped states, use the existing one
//else create new IOAutomaton-State
helper CommonConcepts::State::transformState(inout automaton : IOAutomatonModel::Automaton) : IOAutomatonModel::State {
	if(automaton.states.name->includes(self.name)) {
		return automaton.states->selectOne(s | s.name = self.name);
	}
	else {
		var state : IOAutomatonModel::State := object IOAutomatonModel::State {};
		state.name := self.name;
		automaton.states += state;
		return state;
	};
}



